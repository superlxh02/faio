# 同步原语

**全局设计原则**：

- **协程友好**：锁被占用或条件不满足时，不阻塞 OS 线程，而是挂起当前协程、把其 `coroutine_handle<>` 放入等待结构；当锁释放或条件满足时，通过 **runtime::detail::push_task_to_local_queue(handle)** 把协程重新放入任务队列，由 Worker 调度恢复。
- **与运行时耦合**：必须在 faio 的 Worker 线程上调用，否则 push_task_to_local_queue 可能无效或行为未定义。

---

## 1. mutex（协程互斥锁）

### 1.1 设计

- **互斥语义**：与 `co_await` 配合，提供「拿不到锁就挂起、拿到再继续」的协程互斥。`co_await mutex.lock()` 在拿到锁时直接继续，拿不到时把当前协程挂起并加入等待链；`unlock()` 时唤醒一个等待者。
- **公平**：唤醒顺序为「先等待的先被唤醒」（FIFO）。实现上入队得到 LIFO 链，unlock 时反转为 FIFO 后按序唤醒。
- **头插LIFO+链表反转**：等待链只维护一个原子头指针 `_state`，入队一次 CAS 完成、不引入尾指针或遍历——头插只需改这一处原子变量，尾插则要同时改「尾的 _next」和「尾指针」两处，无法单次 CAS。故采用头插得到 LIFO 链，unlock 时（仅持锁者执行，无并发）再反转为 FIFO 后按序唤醒。
- **状态编码**：用单一原子指针 `_state` 同时表示「未锁 / 已锁无等待者 / 已锁且有等待链头」，避免额外分配；未锁用「mutex 自身地址」作为特殊标记，与 `nullptr`（已锁无等待者）和 Awaiter*（链头）区分。

### 1.2 代码分析

#### 1.2.1 mutex 的数据结构

**Awaiter 的数据成员**（链表节点）：

```cpp
class Awaiter {
  // ...
private:
  mutex &_mutex;
  Awaiter *_next;                   // 指向下一个节点，链表节点的 next 指针
  std::coroutine_handle<> _handle;   // 当前等待的协程句柄
};
```

**mutex 的数据成员**（链头与状态）：

```cpp
class mutex {
  // ...
private:
  auto locking_state() -> Awaiter * { return nullptr; }
  auto unlocking_state() -> Awaiter * {
    return reinterpret_cast<Awaiter *>(this);
  }
  std::atomic<Awaiter *> _state;       // LIFO链头
  Awaiter *_fifo_awaiters{nullptr};    // 仅 unlock 使用：FIFO 链头
};
```

**链表结构说明**：

- **Awaiter**：链表节点类型；每个等待中的协程对应一个 Awaiter 对象，除 `_next` 外还保存 `_handle`（协程句柄），用于被唤醒时恢复。
- **Awaiter::_next**：链表节点的后继指针，指向下一个 Awaiter 节点；各节点通过 `_next` 串成一条单链。
- **mutex::_state**：有等待者时，即由 Awaiter 节点组成的 **LIFO 等待链的链头**（头插法入队，新节点成为新链头，故为 LIFO）。
- **mutex::_fifo_awaiters**：普通指针，仅 unlock 路径使用、无并发。unlock 时从 `_state` 取走整条 LIFO 链并反转为 FIFO 后，反转后的链头存于此，代表整条「待唤醒」链表；按该链顺序逐个唤醒并后移。

**mutex::_state详细说明**：`_state` 的三种取值对应设计中的「避免额外分配、用 mutex 自身地址作未锁标记」：

| _state 的值                 | 含义                                                                                   |
| --------------------------- | -------------------------------------------------------------------------------------- |
| **unlocking_state()** | 未锁。实现为 `reinterpret_cast<Awaiter*>(this)`，即 mutex 自身地址当作「特殊标记」。 |
| **locking_state()**   | 已锁且当前没有等待者。实现为 `nullptr`。                                             |
| **Awaiter***          | 已锁且存在等待者；_state 即等待链的 LIFO 链头。                                        |

**公平性**：若按 LIFO 顺序唤醒会变成「后等先得」，因此增加 `_fifo_awaiters`：从 `_state` 取出整条 LIFO 链后反转为 FIFO，链头存到 `_fifo_awaiters`，再按该链顺序逐个唤醒。

#### 1.2.2 Awaiter 的实现

Awaiter 负责「抢锁或入队并挂起」：保存当前协程的 handle、在 await_suspend 里根据 _state 做 CAS，要么抢到锁（返回 false 不挂起），要么把自己挂到等待链头（返回 true 挂起）。**协程友好**体现在：拿不到锁时只挂起协程并链入 _state，不阻塞 OS 线程；恢复由 unlock 侧通过 push_task_to_local_queue(_handle) 触发。

```cpp
class Awaiter {
  mutex &_mutex;
  Awaiter *_next;              // 等待链中下一个（LIFO 链）
  std::coroutine_handle<> _handle;
public:
  explicit Awaiter(mutex &mutex) : _mutex{mutex} {}

  auto await_ready() const noexcept -> bool { return false; }

  auto await_suspend(std::coroutine_handle<> handle) noexcept -> bool {
    _handle = handle;
    auto state = _mutex._state.load(std::memory_order::relaxed);
    while (true) {
      if (state == _mutex.unlocking_state()) {
        if (_mutex._state.compare_exchange_weak(state, _mutex.locking_state(),
                                                std::memory_order::acquire,
                                                std::memory_order::relaxed)) {
          return false;   // 抢到锁，不挂起
        }
      } else {
        _next = state;   // 当前链头（可能是 nullptr 或别的 Awaiter*）
        if (_mutex._state.compare_exchange_weak(state, this,
                                                std::memory_order::acquire,
                                                std::memory_order::relaxed)) {
          break;         // 自己成为新链头，挂起
        }
      }
    }
    return true;
  }

  constexpr void await_resume() const noexcept {}
};
```

- **await_ready** 恒为 false：总是先尝试抢锁，再决定是否挂起。
- **await_suspend**：若当前为 **unlocking_state**，CAS 将 _state 改为 locking_state()，成功则返回 false，协程不挂起（已持锁）；若当前已锁，则**头插**入等待链：`_next = state`（指向当前链头），CAS 把 _state 从 state 改为 this，使当前 Awaiter 成为新链头，成功则 break 并返回 true，协程挂起。
- **await_resume**：无操作；被 unlock 唤醒的协程从挂起点恢复后，逻辑上已「拿到锁」（因为是被选中的唯一等待者）。

#### 1.2.3 lock() 的实现

`lock()` 返回 `Awaiter{*this}`，因此 `co_await mutex.lock()` 会使用上一节的 Awaiter：先尝试通过 await_suspend 抢锁或入队，拿不到则挂起；被 unlock 唤醒后从 await_resume 返回，调用方继续执行即表示已持锁。

#### 1.2.4 unlock() 的实现

无等待者时直接 CAS 把 _state 从 locking_state 置为 unlocking_state；有等待者时先从 _state 取出整条 LIFO 链，反转为 FIFO 存到 _fifo_awaiters，再唤醒队首（**公平性**与**协程恢复**在此体现）：

```cpp
void unlock() noexcept {
  if (_fifo_awaiters == nullptr) {
    auto state = _state.load(std::memory_order::relaxed);
    if (state == locking_state() &&
        _state.compare_exchange_strong(state, unlocking_state(),
                                       std::memory_order::acquire,
                                       std::memory_order::relaxed)) {
      return;   // 无等待者，直接释放
    }
    // 持锁期间有人入队：取出整条 LIFO 链（链头在 lifo_awaiters）
    auto lifo_awaiters = _state.exchange(locking_state(), std::memory_order::acquire);
    // 将 LIFO 反转为 FIFO，反转后的链头存到 _fifo_awaiters（代表整条待唤醒链表）
    while (lifo_awaiters != nullptr) {
      std::tie(_fifo_awaiters, lifo_awaiters, lifo_awaiters->_next) =
          std::tuple{lifo_awaiters, lifo_awaiters->_next, _fifo_awaiters};
    }
  }
  assert(_fifo_awaiters != nullptr);
  runtime::detail::push_task_to_local_queue(_fifo_awaiters->_handle);
  _fifo_awaiters = _fifo_awaiters->_next;
}
```

- 若 **_fifo_awaiters 为空**：先尝试 CAS 从 locking_state 变为 unlocking_state；成功则 return。若 CAS 失败，说明持锁期间有协程入队，_state 已是等待链的链头；用 **exchange** 取出整条 LIFO 链，在 while 里**反转为 FIFO**，反转后的链头存到 _fifo_awaiters，即整条链由 _fifo_awaiters 与各节点 _next 表示。
- 取 _fifo_awaiters 所指队首节点，对其 _handle 调用 **push_task_to_local_queue** 恢复协程，再令 _fifo_awaiters = _fifo_awaiters->_next 后移链头。被恢复的协程在 await_resume 之后继续执行，逻辑上已持锁。

#### 1.2.5 try_lock() 的实现

对应设计中的**非阻塞接口**：不挂起协程，仅当 _state 为 unlocking_state 时 CAS 为 locking_state 并返回 true，否则返回 false。

```cpp
[[nodiscard]] auto try_lock() noexcept -> bool {
  auto state = _state.load(std::memory_order::relaxed);
  return _state.compare_exchange_strong(state, locking_state(),
                                        std::memory_order::acquire,
                                        std::memory_order::relaxed);
}
```

---

## 2. condition_variable（条件变量）

### 2.1 设计

- **与 mutex 配合**：必须在**已持 mutex** 下调用 **wait(mutex, pred)**。若 pred() 为 false，则释放锁并挂起当前协程，进入条件变量的等待链；被 **notify_one** 或 **notify_all** 唤醒后，会重新去抢 mutex，抢到后再检查 pred()。
- **经典语义**：形成「while (!pred()) { 释放锁并等待; 抢锁; }」的循环，避免虚假唤醒；调用方以「持锁 → 检查条件 → 不满足则 wait → 被唤醒后再次持锁并检查」的方式使用。
- **唤醒粒度**：notify_one 只从等待链取一个节点并恢复其协程；notify_all 取下整条链并依次恢复所有等待者。等待链用 LIFO 组织（新等待者插在链头），仅用于保存挂起协程的 Awaiter，不保证唤醒顺序。

### 2.2 代码分析

#### 2.2.1 condition_variable 的数据结构

condition_variable 仅有一个核心成员：**原子指针 `_awaiters`**，表示等待链的链头。等待链通过每个 Awaiter 的 `_next` 串成 **LIFO**（新节点 CAS 插在链头），对应设计中的「等待链用 LIFO 组织」。不保证唤醒顺序，只用于保存挂起协程的 Awaiter，供 notify_one / notify_all 取下并恢复。**与 mutex 配合**在数据结构上体现为：Awaiter 内部持有 `mutex &_mutex`，入队时在持锁下操作 _awaiters，并在挂起前释放该 mutex（见 Awaiter 实现）。

```cpp
class condition_variable {
  // ... Awaiter 见下节 ...
  std::atomic<Awaiter *> _awaiters{nullptr};  // 等待链头（LIFO）
};
```

#### 2.2.2 Awaiter 的实现

Awaiter 负责「在已持 mutex 下释放锁并把自己挂到 _awaiters，然后挂起」。**协程友好**体现为：条件不满足时不阻塞 OS 线程，只挂起协程；被 notify 唤醒后由 push_task_to_local_queue(_handle) 恢复，再在 wait() 里重新抢 mutex。**先入队再释放锁**通过 `std::lock_guard<mutex> lock{_mutex, std::adopt_lock}` 实现：await_suspend 执行时仍持锁，把当前 Awaiter 链入 _cv._awaiters 后，函数返回时 lock 析构调用 mutex.unlock()，然后协程挂起。

```cpp
class Awaiter {
  condition_variable &_cv;
  mutex &_mutex;
  std::coroutine_handle<> _handle;
  Awaiter *_next{nullptr};   // 等待链下一节点
public:
  Awaiter(condition_variable &cv, mutex &mutex) : _cv{cv}, _mutex{mutex} {}

  auto await_ready() const noexcept -> bool { return false; }

  void await_suspend(std::coroutine_handle<> handle) noexcept {
    _handle = handle;
    std::lock_guard<mutex> lock{_mutex, std::adopt_lock};
    _next = _cv._awaiters.load(std::memory_order::relaxed);
    while (!_cv._awaiters.compare_exchange_weak(_next, this,
                                                std::memory_order::acquire,
                                                std::memory_order::relaxed)) {}
  }
  void await_resume() const noexcept {}
};
```

- **await_ready** 恒为 false，由外层 wait() 的 while 与 predicate 决定是否真正挂起。
- **await_suspend**：在持 mutex 下把当前 Awaiter 设为新链头（_next 指向原 _awaiters），CAS 更新 _awaiters 为 this；lock_guard 析构时释放 mutex，协程挂起。
- **await_resume**：无操作；被 notify 唤醒后，调用方在 wait() 里继续执行 `co_await mutex.lock()` 抢锁。

#### 2.2.3 wait() 的实现

对应设计中的**经典语义**：「while (!pred()) { 释放锁并等待; 抢锁; }」。调用前调用方必须已持 mutex。

```cpp
template <class Predicate>
  requires std::is_invocable_r_v<bool, Predicate>
auto wait(mutex &mutex, Predicate &&predicate) -> task<void> {
  while (!predicate()) {
    co_await Awaiter{*this, mutex};
    co_await mutex.lock();
  }
  co_return;
}
```

若条件不满足，`co_await Awaiter{*this, mutex}` 在 Awaiter 里释放 mutex 并挂到 _awaiters 后挂起。被 notify 唤醒后从 await_resume 返回，接着 **co_await mutex.lock()** 重新抢锁，抢到后再检查 predicate()；若仍为 false 则继续循环，避免虚假唤醒。

#### 2.2.4 notify_one() 与 notify_all() 的实现

对应设计中的**唤醒粒度**：notify_one 只取一个节点并恢复；notify_all 取下整条链并依次恢复。

```cpp
void notify_one() noexcept {
  auto awaiters = _awaiters.load(std::memory_order::relaxed);
  if (awaiters == nullptr) return;
  while (!_awaiters.compare_exchange_weak(awaiters, awaiters->_next,
                                          std::memory_order::acq_rel,
                                          std::memory_order::relaxed)) {}
  awaiters->_next = nullptr;
  condition_variable::resume(awaiters);
}

void notify_all() noexcept {
  auto awaiters = _awaiters.load(std::memory_order::relaxed);
  while (!_awaiters.compare_exchange_weak(awaiters, nullptr,
                                          std::memory_order::acq_rel,
                                          std::memory_order::relaxed)) {}
  condition_variable::resume(awaiters);
}

private:
  static void resume(Awaiter *awaiter) {
    while (awaiter != nullptr) {
      runtime::detail::push_task_to_local_queue(awaiter->_handle);
      awaiter = awaiter->_next;
    }
  }
```

- **notify_one**：CAS 从 _awaiters 取下**一个**节点（原链头），链头改为该节点的 _next，再对该节点调用 **resume**（即 push_task_to_local_queue）。被唤醒的协程会继续执行 wait() 中的 `co_await mutex.lock()`。
- **notify_all**：CAS 把整条链取下（_awaiters 置为 nullptr），对链上每个 Awaiter 依次 push_task_to_local_queue。

---

## 3. channel\<T\>（有界通道）

### 3.1 设计

- **有界多生产者多消费者**：**make(max_cap)** 返回一对 **Sender** 和 **Receiver**，二者共享一个 **Channel**。Sender 上 **send(value)**、Receiver 上 **recv()** 均返回可 `co_await` 的 task；若缓冲满则 send 挂起，若缓冲空则 recv 挂起；若有对方在等则直接配对传递值并恢复对方，不经过缓冲，减少延迟。
- **生命周期与关闭**：Sender/Receiver 通过 shared_ptr 引用 Channel，拷贝时 add_sender/add_receiver，析构或 close 时 sub_sender/sub_receiver。当最后一个 sender 或最后一个 receiver 离开时，调用 **destroy()** 关闭通道并唤醒所有等待者；关闭后未完成的操作在 await_resume 中得到 **ClosedChannel** 错误。
- **互斥与等待队列**：Channel 内部用 mutex 保护「缓冲 + 等待发送者队列 + 等待接收者队列」；send/recv 先抢锁，再在持锁下根据「是否有对方在等、缓冲是否满/空」决定直接配对、写缓冲/读缓冲，还是把自己加入对应等待队列并挂起（挂起前通过 adopt_lock 释放 mutex）。

### 3.2 代码分析

#### 3.2.1 Channel 的数据结构

Channel 是实际持有状态的核心，其数据结构体现设计中的**有界多生产者多消费者**、**互斥与等待队列**和**生命周期与关闭**：

- **有界缓冲**：`RingBuffer<T> _buffer`，容量由构造时传入的 `cap` 指定；内部 `data_.size() == cap + 1`，多一个槽用于区分满/空（见下 RingBuffer）。
- **多生产多消费**：`_num_senders`、`_num_receivers` 原子计数；拷贝 Sender/Receiver 时 add_sender/add_receiver，析构或 close() 时 sub_sender/sub_receiver，最后一个 sub 触发 destroy()。
- **互斥与等待队列**：`mutex _mutex` 保护「缓冲 + 两个等待队列」；`_waiting_senders`、`_waiting_receivers` 为已持锁下入队的发送者/接收者 Awaiter 指针，对应「缓冲满则 send 挂起、缓冲空则 recv 挂起、有对方在等则直接配对」。
- **关闭**：`_is_closed` 原子布尔；destroy() 将其从 false 置为 true 并唤醒所有等待者，await_resume 中返回 `expected` 的 `ClosedChannel` 错误。

```cpp
// channel/channel.hpp
template <typename T> class Channel {
  // ...
private:
  std::atomic<std::size_t> _num_senders;
  std::atomic<std::size_t> _num_receivers;
  RingBuffer<T> _buffer;                         // 环形缓冲区
  std::list<SendAwaiter *> _waiting_senders{};
  std::list<RecvAwaiter *> _waiting_receivers{};
  std::atomic<bool> _is_closed{false};
  mutex _mutex{};
};
```

#### 3.2.2 SendAwaiter 与 RecvAwaiter 的实现

**SendAwaiter** 和 **RecvAwaiter** 是 channel 通信的主要逻辑所在，本质是对**数据**的在不同情况下的不同操作。下面先按「对数据的操作」分析通信本质（与源码注释一致），再对照源码说明。

**通信本质**

通信的主体是**数据**：数据从 sender 经 channel 到达 receiver，要么经过环形缓冲区 _buffer 中转，要么在有人等待时直接从发送者的 _value 交到接收者的 _result。因此按「谁先被调度」分成两种时序，每种时序下是**三种对数据的操作**，每种操作对应一种条件：

1. **Sender 先被调度 —— 三种发送数据的操作**

   - （1）**将当前值放入对应接收者的 _result 里，恢复 receiver 拿数据** → 条件是已经有等待接受数据的 receiver。
   - （2）**将当前值放入缓冲区** → 条件是缓冲区没满。
   - （3）**什么都不做，只是把自己放入等待发送队列**（数据暂不发出，等 receiver 来取）→ 条件是缓冲区满了且通道未关闭。
2. **Receiver 先被调度 —— 三种接收数据的操作**

   - （1）**将当前值从等待中的 sender 的 _value 中取走，放入自己的 _result，恢复 sender** → 条件是已经有等待发送数据的 sender。
   - （2）**从缓冲区中取出值** → 条件是缓冲区不为空。
   - （3）**什么都不做，只是把自己放入等待接收队列**（暂时拿不到数据，等 sender 写入）→ 条件是缓冲区为空且通道未关闭。

综上：**通信主逻辑**就是「在持锁下根据当前状态选择对数据做哪一种操作」——要么把数据交给对方或缓冲，要么暂时交不出去/拿不到而入队挂起；实现上这六种操作分别落在 SendAwaiter 与 RecvAwaiter 的 `await_suspend` 里。
