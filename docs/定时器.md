# 定时器

---

## 1. 概述与常量

faio 的定时器为**多级时间轮**：最底层（Level 0）64 个槽、每槽 1ms；上层每槽管辖一个子时间轮，跨度按 64 的幂增长。任务按「相对当前起点」的 interval 毫秒数落槽，到期时由 Worker 在 `poll()` 里统一扫描并执行。所有时间相关常量在 `detail/runtime/config.hpp` 中：

```cpp
// config.hpp
static inline constexpr std::size_t MAX_LEVEL{6uz};   // 时间轮最大层级
static inline constexpr std::size_t SLOT_SIZE{64uz};   // 每层槽数
static inline constexpr std::size_t SLOT_SHIFT{6uz};  // log2(64) = 6
static inline constexpr std::size_t SLOT_MASK{SLOT_SIZE - 1uz};  // 63
```

层级与跨度关系（`wheel.hpp` 中由 `util::static_pow(SLOT_SIZE, LEVEL)` 等计算）：

| 层级    | 每槽含义                | 总跨度 SPAN_MS     | 用途                          |
| ------- | ----------------------- | ------------------ | ----------------------------- |
| Level 0 | 1ms                     | 64ms               | 叶子层，槽里存 TimerTask 链表 |
| Level 1 | 64ms（一个 Level-0 轮） | 4096ms ≈ 4s       | 槽里存 TimerWheel\<0\>        |
| Level 2 | 4096ms                  | 262144ms ≈ 4.4min | 槽里存 TimerWheel\<1\>        |
| …      | 64^LEVEL ms             | 64^(LEVEL+1) ms    | 递归                          |

**interval** 在所有层都表示「相对 Timer 当前逻辑起点 _start 的毫秒数」。Timer 每次 `poll` 会用 `elapsed_ms()` 推进时间并 `advance_start(elapsed)`，所以起点会前移，interval 是相对上一次推进后的起点。

---

## 2. TimerTask（定时项）

**职责**：表示一个定时项。有两种形态：**sleep**（持有一个协程 handle，到期后恢复协程）和 **IO 超时**（持有一个 `io_user_data_t*`，到期后取消对应 io_uring 请求并写 ETIMEDOUT）。

### 2.1 类定义与两种构造

```cpp
class TimerTask {
public:
  // sleep 场景：到期后恢复 handle 对应的协程
  TimerTask(std::chrono::steady_clock::time_point deadline,
            std::coroutine_handle<> handle)
      : _deadline(deadline), _handle(handle) {}

  // IO 超时场景：到期后取消 user_data 对应的 IO，并写 ETIMEDOUT
  TimerTask(std::chrono::steady_clock::time_point deadline,
            io::detail::io_user_data_t *user_data)
      : _deadline(deadline), _user_data(user_data) {}
  // ...
  std::coroutine_handle<> _handle{nullptr};
  std::chrono::steady_clock::time_point _deadline;
  io::detail::io_user_data_t *_user_data{nullptr};
  std::unique_ptr<TimerTask> _next{nullptr};   // 同槽链表下一节点
};
```

同一槽位上多个任务通过 `_next` 串成链表，头插。

### 2.2 execute：到期时执行

到期后由时间轮的 `handle_expired_tasks` 调用 `execute(local_queue, global_queue)`：

```cpp
template <typename LocalQueue, typename GlobalQueue>
void TimerTask::execute(LocalQueue &local_queue, GlobalQueue &global_queue) {
  if (_handle != nullptr) {
    // sleep 路径：把协程句柄放入任务队列，等待 Worker 调度恢复
    local_queue.push_back(_handle, global_queue);
  } else if (_user_data != nullptr) {
    // IO 超时路径：写超时错误码，并提交 io_uring cancel
    _user_data->result = -ETIMEDOUT;
    _user_data->timer_task = nullptr;
    auto sqe = io::detail::current_uring->get_sqe();
    if (sqe != nullptr) {
      io_uring_prep_cancel(sqe, _user_data, 0);
      io_uring_sqe_set_data(sqe, nullptr);
    }
  }
}
```

- **sleep**：只把当前协程的 handle 入队，不阻塞线程；协程在后续某次 `get_next_task` 时被取出并 resume。
- **IO 超时**：把该 IO 请求的 result 设为 `-ETIMEDOUT`，并清掉 `timer_task` 引用，再通过 `io_uring_prep_cancel` 取消未完成的 IO；CQE 或 cancel 结果会在 `IOEngine::drive` 里统一处理并恢复对应协程（见《异步IO》）。

---

## 3. TimerWheel\<0\>（最底层时间轮）

**职责**：叶子层时间轮。64 个槽，槽 i 表示「从当前起点起第 i 毫秒」；每槽一个 **TimerTask 链表**。负责按 1ms 粒度落槽、扫描到期任务并执行、以及 rotate/level_up。

### 3.1 数据成员与常量

```cpp
template <> class TimerWheel<0uz> {
  // ...
  static constexpr std::size_t SPAN_MS = SLOT_SIZE;  // 64ms

  std::array<std::unique_ptr<TimerTask>, SLOT_SIZE> _task_slots{};  // 每槽一条链表
  std::uint64_t _slot_map{0};  // 位图：第 i 位为 1 表示 _task_slots[i] 非空
};
```

`_slot_map` 用于快速跳过空槽（如 `handle_expired_tasks` 里用 `_slot_map & (1ull << i)` 判断，`next_deadline_time` 里用 `std::countr_zero(_slot_map)` 找最近非空槽）。

### 3.2 add_task：按 interval 落槽

```cpp
void add_task(std::unique_ptr<TimerTask> &&task, std::size_t interval) {
  auto slot_idx = interval & SLOT_MASK;   // 0..63
  task->_next = std::move(_task_slots[slot_idx]);
  _task_slots[slot_idx] = std::move(task);
  _slot_map |= (1ull << slot_idx);
}
```

- **slot_idx = interval & 63**：interval 在 0～63 之间，直接作为槽下标，表示「当前起点后第 slot_idx 毫秒」。
- 新任务头插到该槽链表，并置位 `_slot_map`。

### 3.3 remove_task：从链表中移除指定任务

```cpp
void remove_task(TimerTask *task, std::size_t interval) {
  auto slot_idx = interval & SLOT_MASK;
  TimerTask *prev = nullptr;
  TimerTask *current = _task_slots[slot_idx].get();

  while (current != nullptr) {
    if (current == task) {
      if (prev == nullptr) {
        _task_slots[slot_idx] = std::move(current->_next);
      } else {
        prev->_next = std::move(current->_next);
      }
      if (_task_slots[slot_idx] == nullptr) {
        _slot_map &= ~(1ull << slot_idx);
      }
      return;
    }
    prev = current;
    current = current->_next.get();
  }
}
```

按 interval 找到槽，遍历该槽链表，从链中摘掉对应节点；若槽变空则清除 `_slot_map` 对应位。

### 3.4 handle_expired_tasks：扫描 [0, remaining_ms) 并执行

```cpp
template <typename LocalQueue, typename GlobalQueue>
void handle_expired_tasks(LocalQueue &local_queue, GlobalQueue &global_queue,
                          std::size_t &count, std::size_t remaining_ms) {
  auto slots_to_scan = std::min(remaining_ms, SLOT_SIZE);

  for (std::size_t i = 0; i < slots_to_scan; ++i) {
    if ((_slot_map & (1ull << i)) == 0) continue;

    auto task_ptr = std::move(_task_slots[i]);
    _slot_map &= ~(1ull << i);

    while (task_ptr != nullptr) {
      auto next = std::move(task_ptr->_next);
      task_ptr->execute(local_queue, global_queue);
      ++count;
      task_ptr = std::move(next);
    }
  }
}
```

- **remaining_ms**：本层要「消耗」的时间长度（毫秒），即「从当前起点起已经过了多少 ms」。
- 只扫描槽 0 到 `remaining_ms - 1`（最多 64 槽）。对每个非空槽：整条链表移出，逐个 `execute()`，并累加 `count`。这样 Level 0 上「时间推进 remaining_ms」对应的所有到期任务都被处理完。

### 3.5 next_deadline_time：最近到期槽的偏移

```cpp
auto next_deadline_time() const noexcept -> std::size_t {
  if (_slot_map == 0) return SLOT_SIZE;
  return static_cast<std::size_t>(std::countr_zero(_slot_map));
}
```

返回当前轮上最近一个有任务的槽的下标（0～63）；若无任务则返回 64，表示「至少 64ms 内无到期」。

### 3.6 rotate：时间推进后槽位前移

```cpp
void rotate(std::size_t start) {
  if (start == 0 || start >= SLOT_SIZE) return;
  _slot_map >>= start;
  for (std::size_t i = 0; i < SLOT_SIZE - start; ++i) {
    _task_slots[i] = std::move(_task_slots[i + start]);
  }
  for (std::size_t i = SLOT_SIZE - start; i < SLOT_SIZE; ++i) {
    _task_slots[i].reset();
  }
}
```

表示「起点往前挪了 start 毫秒」：前 start 个槽被丢弃，后面槽整体前移，尾部清空。与 Timer 的 `advance_start(ms)` 配合，在每次 poll 处理完到期任务后调用。

---

## 4. TimerWheel\<LEVEL\>（LEVEL ≥ 1，上层时间轮）

**职责**：非叶子层。64 个槽，每槽持有一个 **TimerWheel\<LEVEL-1\>** 子轮；用 interval 的**高位**选槽、**低位**进子轮，实现 O(层级) 的插入与到期扫描。

### 4.1 常量与槽位计算

```cpp
template <std::size_t LEVEL> class TimerWheel {
  using child_wheel = TimerWheel<LEVEL - 1>;

  static constexpr std::size_t CHILD_SPAN_MS = util::static_pow(SLOT_SIZE, LEVEL);   // 64^LEVEL
  static constexpr std::size_t SPAN_MS       = util::static_pow(SLOT_SIZE, LEVEL + 1uz);
  static constexpr std::size_t CHILD_SHIFT   = SLOT_SHIFT * LEVEL;   // 6*LEVEL
  static constexpr std::size_t CHILD_MASK    = CHILD_SPAN_MS - 1uz;

  std::array<std::unique_ptr<child_wheel>, SLOT_SIZE> _wheels_slots{};
  std::uint64_t _slot_map{0};
};
```

- **slot_idx = interval >> CHILD_SHIFT**：等价于 interval / CHILD_SPAN_MS，表示落在「第几个 64^LEVEL ms 的桶」。
- **child_interval = interval & CHILD_MASK**：等价于 interval % CHILD_SPAN_MS，表示在该桶内的偏移，交给子轮。

例如 LEVEL=1，interval=100：CHILD_SHIFT=6，CHILD_MASK=63。slot_idx=1，child_interval=36；即「第 1 个 64ms 块内的第 36ms」，子轮（Level 0）会放到槽 36。

### 4.2 add_task：落槽并懒创建子轮

```cpp
void add_task(std::unique_ptr<TimerTask> &&task, std::size_t interval) {
  auto slot_idx = interval >> CHILD_SHIFT;
  if (slot_idx >= SLOT_SIZE) slot_idx = SLOT_SIZE - 1;

  if (_wheels_slots[slot_idx] == nullptr) {
    _wheels_slots[slot_idx] = std::make_unique<child_wheel>();
    _slot_map |= (1ull << slot_idx);
  }

  auto child_interval = interval & CHILD_MASK;
  _wheels_slots[slot_idx]->add_task(std::move(task), child_interval);
}
```

该槽若无子轮则先创建，再递归 `add_task` 到子轮。

### 4.3 handle_expired_tasks：整槽 + 部分槽

```cpp
template <typename LocalQueue, typename GlobalQueue>
void handle_expired_tasks(..., std::size_t remaining_ms) {
  if (_slot_map == 0 || remaining_ms == 0) return;

  auto full_slots = remaining_ms >> CHILD_SHIFT;       // 完整经过几个「子轮跨度」
  auto partial_remaining = remaining_ms & CHILD_MASK;   // 最后不足一整段的部分

  for (std::size_t i = 0; i < full_slots && i < SLOT_SIZE; ++i) {
    if ((_slot_map & (1ull << i)) == 0) continue;
    _wheels_slots[i]->handle_expired_tasks(..., child_wheel::SPAN_MS);
    _wheels_slots[i].reset();
    _slot_map &= ~(1ull << i);
  }

  if (partial_remaining > 0 && full_slots < SLOT_SIZE) {
    if ((_slot_map & (1ull << full_slots)) != 0) {
      _wheels_slots[full_slots]->handle_expired_tasks(..., partial_remaining);
      if (_wheels_slots[full_slots]->empty()) {
        _wheels_slots[full_slots].reset();
        _slot_map &= ~(1ull << full_slots);
      }
    }
  }
}
```

- **full_slots**：在 remaining_ms 内完整经过了几个「子轮总跨度」；这些槽的子轮要**整轮**处理，传 `child_wheel::SPAN_MS`，处理完即释放子轮。
- **partial_remaining**：不足一整段的那一段 ms；只对第 `full_slots` 个槽传 `partial_remaining`，让子轮只处理「部分到期」。若子轮处理后变空则释放并清 bitmap。

例如 LEVEL=1，remaining_ms=200：full_slots=3，partial_remaining=8；前 3 个槽各处理 64ms，第 4 个槽只处理 8ms。

### 4.4 rotate、level_up、level_down

- **rotate(start)**：按「子轮个数」推进。位图右移 start，槽数组前移，尾部清空；表示时间推进了 start 个子轮跨度。
- **level_up(me)**：当前轮作为父层第 0 槽的子轮，构造 `TimerWheel<LEVEL+1>(std::move(me))`。
- **level_down()**：仅当 LEVEL≥1 时，取出第 0 槽子轮并返回；**can_level_down()** 为「只有第 0 槽非空」时才能降级。

---

## 5. Timer（对外定时器管理器）

**职责**：每个 Worker 持有一个 Timer（通过 `thread_local current_timer` 访问）。内部用 **std::variant** 存根时间轮（可能是 monostate 或 TimerWheel\<0\>～TimerWheel\<MAX_LEVEL\>），维护基准时间 _start 和任务数 _num_entries；提供 add_task、remove_task、poll、next_deadline_ms，以及层级升降级。

### 5.1 根时间轮与 _start

```cpp
inline thread_local Timer *current_timer;

class Timer {
  std::chrono::steady_clock::time_point _start{std::chrono::steady_clock::now()};
  std::size_t _num_entries{0};
  VariantWheelBuilder<MAX_LEVEL + 1uz>::Type _root_wheel{};  // variant<monostate, unique_ptr<TimerWheel<0>>, ...>
};
```

- **_start**：定时器创建或逻辑时间推进的基准点。`elapsed_ms()` 用 `now() - _start` 得到「自起点以来经过的毫秒数」。
- **_root_wheel**：当前根是哪一层时间轮，由 ensure_capacity / try_level_down 动态决定。

### 5.2 add_task（两个重载）

```cpp
auto add_task(std::chrono::steady_clock::time_point deadline,
              std::coroutine_handle<> handle) -> TimerTask * {
  auto task = std::make_unique<TimerTask>(deadline, handle);
  auto *raw = task.get();
  add_task_impl(std::move(task));
  return raw;
}

auto add_task(std::chrono::steady_clock::time_point deadline,
              io::detail::io_user_data_t *user_data) -> TimerTask * {
  auto task = std::make_unique<TimerTask>(deadline, user_data);
  auto *raw = task.get();
  add_task_impl(std::move(task));
  return raw;
}
```

返回裸指针供后续 `remove_task` 使用；所有权在时间轮内。

### 5.3 add_task_impl 与 ensure_capacity

```cpp
void add_task_impl(std::unique_ptr<TimerTask> &&task) {
  auto now = std::chrono::steady_clock::now();
  auto interval_ms = to_ms(task->_deadline - _start);
  auto elapsed = elapsed_ms();

  std::size_t relative_interval = 0;
  if (interval_ms > elapsed) {
    relative_interval = interval_ms - elapsed;
  }

  ensure_capacity(relative_interval);

  std::visit([&](auto &wheel_ptr) {
    if constexpr (!std::is_same_v<T, std::monostate>) {
      if (wheel_ptr) {
        wheel_ptr->add_task(std::move(task), relative_interval);
      }
    }
  }, _root_wheel);

  ++_num_entries;
}
```

- **relative_interval**：任务 deadline 相对「当前已推进到的逻辑时间」的间隔；若已过期则设为 0，会落在 Level 0 的槽 0 附近并很快被 poll 掉。
- **ensure_capacity(relative_interval)**：若根轮为 monostate 或当前层级 SPAN_MS 不足以容纳 relative_interval，则递归 **level_up**（例如根从 Level 0 换成 Level 1，原 Level 0 作为 Level 1 的第 0 槽），直到能放下。
- 然后 visit 根轮，调用其 `add_task(std::move(task), relative_interval)`。

### 5.4 poll：处理到期任务并推进时间

```cpp
template <typename LocalQueue, typename GlobalQueue>
auto poll(LocalQueue &local_queue, GlobalQueue &global_queue) -> std::size_t {
  if (_num_entries == 0) return 0;
  auto elapsed = elapsed_ms();
  if (elapsed == 0) return 0;

  std::size_t count = 0;
  std::visit([&](auto &wheel_ptr) {
    if (wheel_ptr) {
      wheel_ptr->handle_expired_tasks(local_queue, global_queue, count, elapsed);
    }
  }, _root_wheel);

  advance_start(elapsed);   // 无论是否处理了任务，都推进起点

  if (count > 0) {
    _num_entries -= std::min(_num_entries, count);
    try_level_down();
  }
  return count;
}
```

- 用当前 **elapsed_ms()** 作为本层要消耗的 **remaining_ms**，让根轮递归处理所有到期任务。
- **advance_start(elapsed)**：_start 加上 elapsed，并对根轮做 **rotate**，使槽位与新的起点对齐。
- 若有任务被处理，则减少 _num_entries 并 **try_level_down**（若根轮只剩第 0 槽非空等，可降级以节省内存）。

### 5.5 next_deadline_ms、remove_task、advance_start

- **next_deadline_ms()**：visit 根轮求 `next_deadline_time()`（相对当前起点的 ms），再减去 `elapsed_ms()` 得到「距现在」的毫秒数，供 io_uring 的 wait 超时使用。
- **remove_task(task)**：若任务未过期，算出 relative_interval，visit 根轮递归 remove_task；并减 _num_entries、try_level_down。
- **advance_start(ms)**：_start += ms，并对根轮做 rotate；Level 0 直接 rotate(ms)，高层用 `ms >> CHILD_SHIFT` 得到要旋转的槽数。

---

## 6. Sleep（协程挂起指定时长）

**职责**：提供一个可 `co_await` 的 awaiter，在指定 **deadline** 到达时恢复当前协程；内部把当前 handle 交给 `current_timer->add_task(deadline, handle)`。

### 6.1 完整实现

```cpp
class Sleep {
public:
  explicit Sleep(std::chrono::steady_clock::time_point deadline)
      : _deadline(deadline) {}

  auto await_ready() const noexcept -> bool {
    return _deadline <= std::chrono::steady_clock::now();
  }

  auto await_suspend(std::coroutine_handle<> handle) noexcept -> void {
    runtime::detail::timer::current_timer->add_task(_deadline, handle);
  }

  auto await_resume() const noexcept -> void {}

private:
  std::chrono::steady_clock::time_point _deadline;
};
```

- **await_ready**：若 deadline 已到或已过，直接返回 true，不挂起。
- **await_suspend**：把当前协程的 handle 注册到当前 Worker 的 Timer，到期后 Timer 在 handle_expired_tasks 里对该任务 execute，即把 handle 入队，协程在后续调度中恢复。
- **await_resume**：无返回值；sleep 正常唤醒只表示「时间到了」。

用户通过 `faio::time::sleep(duration)` 或 `sleep_until(time_point)` 得到包装了 deadline 的 Sleep，再 `co_await` 即可。

---

## 7. Interval（周期 tick）

**职责**：按固定周期产生「tick」。每次 `co_await tick()` 会挂起到下一个 tick 时间点；支持 **MissedTickBehavior**（Burst / Delay / Skip）控制「错过多次 tick」时的行为。

### 7.1 构造与 tick()

```cpp
enum class MissedTickBehavior {
  Burst,   // 尽快补发所有错过的 tick（连续触发直到追上）
  Delay,   // 从当前时间开始延迟一个 period
  Skip,    // 跳过错过的 tick，对齐到下一个自然周期点
};

class Interval {
public:
  Interval(std::chrono::steady_clock::time_point first_expired_time,
           std::chrono::nanoseconds period,
           MissedTickBehavior behavior = MissedTickBehavior::Burst)
      : _deadline{first_expired_time + period}, _period{period}, _behavior{behavior} {}

  auto tick() noexcept -> Sleep {
    auto expired_time = _deadline;
    _deadline = next_timeout();
    return Sleep{expired_time};
  }
  // ...
private:
  std::chrono::steady_clock::time_point _deadline;
  std::chrono::nanoseconds _period;
  MissedTickBehavior _behavior;
};
```

- **tick()**：返回一个 **Sleep**，其 deadline 为当前保存的 _deadline；然后根据策略更新 _deadline 为「下一次 tick」的时间（next_timeout）。用户 `co_await tick()` 即挂起到当前 _deadline，到期后恢复，再调用 tick() 得到下一个 Sleep，如此循环。

### 7.2 next_timeout：错过 tick 的三种策略

```cpp
auto next_timeout() -> std::chrono::steady_clock::time_point {
  auto now = std::chrono::steady_clock::now();
  switch (_behavior) {
  case MissedTickBehavior::Burst:
    return _deadline + _period;
  case MissedTickBehavior::Delay:
    return now + _period;
  case MissedTickBehavior::Skip: {
    if (_deadline >= now) {
      return _deadline + _period;
    }
    auto missed_ns = (now - _deadline).count();
    auto period_ns = _period.count();
    auto skip = missed_ns / period_ns + 1;
    return _deadline + std::chrono::nanoseconds{skip * period_ns};
  }
  }
  std::unreachable();
}
```

- **Burst**：下次 deadline 总是「当前 _deadline + period」；若中间错过多次，下次 tick 仍按原节奏，可能很快再次到期（「追上去」）。
- **Delay**：若本轮已过期，下次从 **now + period** 开始，不追历史。
- **Skip**：若已过期，计算错过了多少个完整 period（skip），下次对齐到 _deadline + skip*period，即「跳到下一个自然周期点」。

### 7.3 reset 系列

- **reset()**：下一个 tick 在「当前时间 + period」。
- **reset_immediately()**：下一个 tick 的 deadline 设为 now，即下次 tick() 返回的 Sleep 会 await_ready 为 true 或很快到期。
- **reset_after(after)** / **reset_at(deadline)**：按相对或绝对时间设置下一个 tick。

---

## 8. Timeout\<IO\>（IO 超时包装）

IO 超时由 **time::detail::Timeout** 包装任意 **IORegistrantAwaiter**：在 await_suspend 里先 `current_timer->add_task(deadline, &_user_data)` 注册一个 TimerTask（IO 超时形态），再调用原 IO 的 await_suspend。到期时 TimerTask::execute 写 ETIMEDOUT 并 cancel；正常完成时 drive 里会 remove_task。详见《异步IO》。
