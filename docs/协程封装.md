# 协程封装

---

## 1. 类

| 类 / 结构              | 所在文件                  | 职责与含义                                                                                                                                                                                                                                                                          |
| ---------------------- | ------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **task\<T\>**          | detail/coroutine/task.hpp | 对外协程类型：持有一个 `coroutine_handle<promise_type>`，不可拷贝只可移动。提供 `operator co_await()` 使本 task 可作为被等待对象；`take()` 取出句柄并置空，供 spawn 等交给运行时。                                                                                                  |
| **base_task_promise**  | task.hpp                  | 所有 task 的 promise 公共基类：**initial_suspend** 返回 suspend_always（惰性）；**final_suspend** 返回 final_awaiter（结束挂起）；**unhandled_exception** 保存异常；**\_caller** 记录「谁在等我」；**\_on_complete / _on_complete_arg** 为可选的完成回调（block_on 子任务追踪用）。 |
| **task_promise\<T\>**  | task.hpp                  | 继承 base，T 非 void 时：**return_value** 存结果到 optional\<T\>，**expected()** 取结果或重抛异常；void 特化只有 **return_void** 和 **expected()**。                                                                                                                                |
| **final_awaiter**      | task.hpp                  | 协程**最终挂起**用的 awaiter：先调完成回调，再若有 _caller 则返回 _caller（恢复调用者），否则顶层协程则处理异常或 noop。                                                                                                                                                            |
| **task::base_awaiter** | task.hpp                  | **co_await task** 时用的内部 awaiter：await_ready 看句柄空或 done；await_suspend 把 caller 存到 callee 的 _caller 并返回 callee 句柄（把执行权交给被等协程）；await_resume 由子类实现，调 promise().expected() 取结果。                                                             |

**caller / callee**：调用 `co_await` 的协程是 **caller**，被等待的 task 是 **callee**。base_awaiter 在 await_suspend 里把 caller 记在 callee 的 `_caller` 上，并返回 callee 的句柄，从而「caller 挂起、callee 执行」；callee 结束时 final_awaiter 根据 `_caller` 决定恢复调用者或处理顶层异常。完成回调在 final_awaiter 里与「恢复 caller」同一处执行，便于 block_on/spawn 做分组计数。

---

## 2. 设计目标

- **可被 co_await**：`task<T>` 实现 `operator co_await()`，使 `co_await other_task()` 合法；调用者挂起直到被调用者完成并取回结果。
- **结束时挂起**：final_suspend 返回 final_awaiter，协程跑完后再次挂起，不自动销毁，便于把结果/异常交给 caller 或执行完成回调。

---

## 3. 关键源码

### 3.1 base_awaiter：caller 挂起、把执行权交给 callee

```cpp
struct base_awaiter {
  std::coroutine_handle<promise_type> _callee;

  base_awaiter(std::coroutine_handle<promise_type> callee) noexcept : _callee(callee) {}

  constexpr bool await_ready() const noexcept {
    return !_callee || _callee.done();
  }

  template <typename promisetype>
  std::coroutine_handle<> await_suspend(std::coroutine_handle<promisetype> caller) const noexcept {
    _callee.promise()._caller = caller;
    return _callee;
  }
};
```

- **await_ready**：若 callee 为空或已完成，则不挂起，直接进 await_resume 取结果。
- **await_suspend(caller)**：把「调用者」记在 callee 的 promise 里（_caller = caller）；返回 _callee 表示「请恢复 callee」。这样当前执行流会去跑 callee，caller 挂起；等 callee 结束时在 final_awaiter 里会返回 _caller，从而恢复 caller，caller 在 await_resume 里从 promise 取结果。

也就是说：「谁在等我」和「等谁」的绑定靠 _caller 和「返回哪个 handle」完成；整个链是 **caller 挂起 → callee 执行 → callee 结束 → 恢复 caller → caller 取结果**。

### 3.2 final_awaiter：结束时的回调与控制权交还

```cpp
struct final_awaiter {
  constexpr bool await_ready() const noexcept { return false; }

  template <typename T>
  std::coroutine_handle<> await_suspend(std::coroutine_handle<T> callee) const noexcept {
    if (callee.promise()._on_complete) {
      callee.promise()._on_complete(callee.promise()._on_complete_arg);
    }
    if (callee.promise()._caller) {
      return callee.promise()._caller;
    } else {
      if (callee.promise()._exception != nullptr) {
        try { std::rethrow_exception(callee.promise()._exception); }
        catch (const std::exception &ex) {
          std::cerr << std::format("catch a exception: {}", ex.what());
          std::terminate();
        } catch (...) { ... }
      }
      return std::noop_coroutine();
    }
  }
  constexpr void await_resume() const noexcept {}
};
```

- **await_ready** 恒 false：协程结束时总是先挂起一次，不立刻销毁。
- **await_suspend(callee)**：
  1. 若有完成回调（block_on 给子 task 挂的），先调用，用于把「本协程结束」算进 block_on 的 pending_count。
  2. 若有 _caller：返回 _caller，即恢复「正在 co_await 我的那个协程」，由它在 await_resume 里取结果或接异常。
  3. 若无 _caller（顶层协程）：若有异常则打印并 terminate；否则返回 noop_coroutine()，该协程句柄由外部管理生命周期（如 block_on 的外壳协程会由运行时负责）。

完成回调与控制权交还在同一处完成，与《协程并发接口》里的 block_on 分组、spawn 完成计数一致。

### 3.3 task::operator co_await 与 await_resume

```cpp
auto operator co_await() const & noexcept {
  struct awaiter : public base_awaiter {
    decltype(auto) await_resume() const noexcept {
      if (!this->_callee) throw std::logic_error("handle is nullptr");
      return this->_callee.promise().expected();
    }
  };
  return awaiter{_handle};
}
```

左值/右值重载区别只在 await_resume 里是 `expected()` 还是 `std::move(...expected())`（void 时无 move）。**expected()** 会检查 _exception，非空则 rethrow，否则返回存的值；这样异常从 callee 传到 caller。
