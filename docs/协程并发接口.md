# 协程并发接口


---

## 1. 类

| 类 / 结构                         | 所在文件    | 职责与含义                                                                                                                                                                                                                       |
| --------------------------------- | ----------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **completion_signal**             | context.hpp | 完成信号：一个原子状态 +`wait()`/`mark_ready()`。阻塞线程在 `wait()` 上挂起，直到有人 `mark_ready()`，用于「全部完成才返回」。                                                                                                   |
| **block_on_tracker**              | context.hpp | **block_on 的「分组」核心**：维护当前 block_on 上下文中**未完成协程个数** `pending_count`，以及一个 completion_signal。每有一个子协程完成就 `complete_subtask()` 减一，减到 0 时置 signal，阻塞线程才从 `wait_all_done()` 返回。 |
| **current_tracker**               | context.hpp | thread_local 指针，指向当前线程正在执行的 block_on 所对应的 tracker。Worker 执行「被 block_on 派发的协程」时会被设为该 tracker，从而其内部 spawn 出去的 task 都挂到同一组。                                                      |
| **result_slot\<T\>**              | context.hpp | 存一个协程的返回值或异常，并带一个 completion_signal。worker 线程把结果写入 slot 并 `mark_ready()`，阻塞线程在 `get()` 里先 `wait()` 再取结果或重抛异常。                                                                        |
| **block_on_coro / wait_all_coro** | context.hpp | **外壳协程**：内部只做 `co_await` 用户 task、把结果写入 result_slot、并调用 `tracker->complete_subtask()`。这样「主 task 或 wait_all 的某一个 task」完成时，既写回结果，又参与 block_on 的计数。                                 |
| **runtime_context**               | context.hpp | 用户可见的运行时入口，持有 Config 和 RuntimePoller；提供静态 `spawn`、成员 `block_on`/`wait_all`。                                                                                                                               |

分组依赖 **block_on_tracker** 的 `pending_count` 与 **completion_signal**：主 task 与所有在该 block_on 上下文中 spawn 的子 task 通过 register_subtask / on_task_complete → complete_subtask 参与同一组计数；减到 0 时 mark_ready，阻塞线程才返回。**current_tracker** 标记当前线程在为哪个 block_on 的组「打工」，spawn 时据此决定是否挂上该组的完成回调和计数。**外壳协程**把「执行用户 task + 写 result_slot + complete_subtask」绑在一起；**result_slot** 只负责单协程结果与单协程完成信号，与「整组完成」的 completion_signal 分开。

---

## 2. block_on 的「分组」机制：主 task + 所有 spawn 子 task

**目标**：`block_on(ctx, main_task)` 必须等两件事都完成才返回：

1. **主 task**（传入的协程）执行完并取回返回值；
2. **主 task 在执行过程中通过 spawn 派生的所有子 task** 也全部执行完。

若只等主 task 返回就 `slot.get()`，子 task 可能还在跑甚至继续 spawn，导致「block_on 返回后仍有协程在运行」。

### 2.1 分组靠的是「计数 + 完成回调」

- **pending_count**：当前 block_on 这一组里，还有多少个协程没结束（包括主 task 和所有已 spawn 的子 task）。
- **规则**：
  - 主 task 被当作 1 个未完成：`tracker.register_subtask()` 一次；
  - 每次 **spawn(task)** 时，若当前线程有 `current_tracker`，就再 `tracker.register_subtask()`，并把该 task 的 promise 的**完成回调**设为 `block_on_tracker::on_task_complete`，参数为 tracker；
  - 任意一个被追踪的协程**结束时**（在 promise 的 final_awaiter 里），会调用 `_on_complete(_on_complete_arg)`，即 `on_task_complete(tracker)`，里面执行 `tracker->complete_subtask()`，把 pending_count 减 1；
  - 当 pending_count 从 1 减到 0 时，说明「主 task + 所有已 spawn 的子 task」都结束了，此时在 `complete_subtask()` 里对 completion_signal 调用 `mark_ready()`，阻塞线程的 `tracker.wait_all_done()` 才返回。

主 task 的完成由**外壳协程**在 `co_await main_task` 返回后调用 `tracker->complete_subtask()` 体现；每个 spawn 出去的子 task 的完成由该子 task 的 promise 上挂的 `on_task_complete` 在协程结束时调用 `complete_subtask()` 体现。这样「主 task + 当前 block_on 上下文中 spawn 的所有子 task」归为**一组**，用同一个 pending_count 和同一个 completion_signal 统一等待。

### 2.2 current_tracker 的作用：子 task 归到哪一组？

只有**正在执行「被 block_on 派发出去的协程」的那个 Worker 线程**上，才会在进入外壳协程时把 `current_tracker` 设为该 block_on 的 tracker。**spawn** 时：若 `detail::current_tracker != nullptr`，就认为当前在某个 block_on 的「组内」，于是给 tracker 加一票并给被 spawn 的 task 挂上 `on_task_complete`；否则不参与任何 block_on 的计数。因此同一时刻每个 Worker 上至多有一个 block_on 的「组」生效；所有在该组内 spawn 的子 task 都会把完成事件算进同一个 pending_count，直到减到 0，对应的 block_on 才返回。

---

## 3. 关键源码与逻辑

### 3.1 completion_signal：无锁等待「完成」

```cpp
// context.hpp
enum class signal_status : std::uint8_t { pending = 0, ready = 1 };

struct completion_signal {
  std::atomic<signal_status> status{signal_status::pending};

  void mark_ready() {
    status.store(signal_status::ready, std::memory_order::release);
    status.notify_all();
  }

  bool is_ready() const noexcept {
    return status.load(std::memory_order::acquire) == signal_status::ready;
  }

  void wait() const noexcept {
    if (is_ready()) return;
    for (int i = 0; i < 32; ++i) {
      if (is_ready()) return;
      __builtin_ia32_pause();  // 或 aarch64 的 yield
    }
    while (!is_ready()) {
      status.wait(signal_status::pending, std::memory_order::acquire);
    }
  }
};
```

表示「是否已完成」的标记。`wait()` 先短自旋 32 次（减少刚就绪时的延迟），再进入 `atomic::wait()` 真正阻塞，直到 `mark_ready()` 被调用。在 block_on 中，`block_on_tracker` 持有一个 `completion_signal completion`；当 `pending_count` 减到 0 时在 `complete_subtask()` 里调用 `completion.mark_ready()`，阻塞线程调的是 `tracker.wait_all_done()` → `completion.wait()`，从而实现「等这一组全部完成」。

### 3.2 block_on_tracker：分组计数与完成回调

```cpp
struct block_on_tracker {
  std::atomic<std::size_t> pending_count{0};
  completion_signal completion;

  void register_subtask() {
    pending_count.fetch_add(1, std::memory_order::acq_rel);
  }

  void complete_subtask() {
    if (pending_count.fetch_sub(1, std::memory_order::acq_rel) == 1) {
      completion.mark_ready();
    }
  }

  void wait_all_done() { completion.wait(); }

  static void on_task_complete(void *arg) {
    auto *tracker = static_cast<block_on_tracker *>(arg);
    tracker->complete_subtask();
  }
};

inline thread_local block_on_tracker *current_tracker{nullptr};
```

- **register_subtask()**：组内多了一个「未完成协程」（主 task 或一次 spawn），计数 +1。
- **complete_subtask()**：某个被追踪的协程结束，计数 -1；若减完之后是 0，说明整组都结束了，置 `completion.mark_ready()`，唤醒在 `wait_all_done()` 上阻塞的线程。
- **on_task_complete**：给 task 的 promise 的 `_on_complete` 用；协程在 final_suspend 的 await_suspend 里会调用 `_on_complete(_on_complete_arg)`，从而把「这个协程结束」算进当前 tracker 的组里。

### 3.3 外壳协程：把主 task 完成与结果写回、计数绑定在一起

```cpp
template <typename T>
task<void> block_on_coro(task<T> t, result_slot<T> *slot, block_on_tracker *tracker) {
  auto prev_tracker = current_tracker;
  current_tracker = tracker;   // 进入本组，后续 spawn 都会挂到这个 tracker
  try {
    if constexpr (std::is_void_v<T>) {
      co_await std::move(t);
      slot->set_value();
    } else {
      auto result = co_await std::move(t);
      slot->set_value(std::move(result));
    }
  } catch (...) {
    slot->set_exception(std::current_exception());
  }
  current_tracker = prev_tracker;
  tracker->complete_subtask();   // 主 task 完成，计数 -1
}
```

- **current_tracker = tracker**：执行主 task 的 Worker 在此期间，所有 **spawn** 都会看到 `current_tracker == tracker`，从而 `register_subtask()` 并挂 `on_task_complete`，子 task 都算进同一组。
- **co_await std::move(t)**：真正跑用户的主 task，拿返回值或异常。
- **slot->set_value / set_exception**：把结果交给阻塞线程（slot 带自己的 completion_signal，`get()` 里会 wait）。
- **tracker->complete_subtask()**：主 task 在组内结束，pending_count 减 1；若此时减到 0，阻塞线程的 `wait_all_done()` 会返回。

主 task 的完成既写了 result_slot，又推了一次 complete_subtask，与「所有 spawn 子 task 的完成」共用同一个 pending_count。

### 3.4 block_on 主流程：从调用到返回

```cpp
template <typename T> auto block_on(task<T> t) -> T {
  detail::result_slot<T> slot;
  detail::block_on_tracker tracker;
  tracker.register_subtask();   // 主 task 占 1

  auto wrapper = detail::block_on_coro<T>(std::move(t), &slot, &tracker);
  auto handle = wrapper.take();

  runtime::detail::push_task_to_global_queue(handle);   // 主线程没有 uring，交给 worker
  tracker.wait_all_done();   // 等 pending_count 减到 0（主 + 所有 spawn）
  return slot.get();         // 再等 slot 就绪并取结果
}
```

主 task 只算 1 个未完成，所以只 `register_subtask()` 一次。外壳协程被投递到全局队列，由某个 Worker 执行；该 Worker 执行期间 `current_tracker` 被设为该 tracker，其上的 spawn 都会挂到同一组。`wait_all_done()` 等的是「主 task + 所有已 spawn 子 task」都调过 `complete_subtask()`。`slot.get()` 只负责取主 task 的返回值或异常，与「分组完成」是两件事：分组保证没有遗漏的子协程还在跑，slot 保证拿到主 task 的结果。

### 3.5 spawn：入组与入队

```cpp
template <typename T> static void spawn(task<T> &&t) {
  auto handle = t.take();

  if (auto *tracker = detail::current_tracker) {
    tracker->register_subtask();
    auto &promise = handle.promise();
    promise._on_complete = &detail::block_on_tracker::on_task_complete;
    promise._on_complete_arg = tracker;
  }

  if (runtime::detail::current_worker != nullptr) {
    runtime::detail::push_task_to_local_queue(handle);
  } else {
    runtime::detail::push_task_to_global_queue(handle);
  }
}
```

若有 `current_tracker`：当前在某个 block_on 的组内，则**给这一组加一票**（register_subtask），并让这个 task 在**结束时**回调 `on_task_complete(tracker)`，即 complete_subtask，该子 task 的结束会被算进同一组。入队逻辑：当前是 Worker 则进本地队列，否则进全局队列，与「分组」无关，只影响调度性能。

### 3.6 wait_all：多 task 一组，每个一个 slot

**wait_all** 为每个 task 单独建一个 result_slot 和一个 wait_all_coro 外壳；但**共用一个 block_on_tracker**，且一开始就把 **pending_count 设为 N**（task 个数），不再对主 task 单独 register，而是每个外壳结束时都 `complete_subtask()`。这样 N 个 task 构成「一组」，等 N 次 complete_subtask 后 pending_count 归零，`wait_all_done()` 返回；每个 task 的结果从各自的 slot 里 get 出来，组成 tuple 返回。逻辑与 block_on 一致，只是主 task 变成 N 个并行 task，每个一个 slot、一个外壳。
